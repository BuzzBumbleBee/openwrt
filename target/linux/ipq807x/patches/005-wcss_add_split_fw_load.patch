--- a/drivers/remoteproc/qcom_q6v5_wcss.c
+++ b/drivers/remoteproc/qcom_q6v5_wcss.c
@@ -11,8 +11,10 @@
 #include <linux/of_reserved_mem.h>
 #include <linux/platform_device.h>
 #include <linux/regmap.h>
+#include <linux/clk.h>
 #include <linux/reset.h>
 #include <linux/soc/qcom/mdt_loader.h>
+#include <linux/qcom_scm.h>
 #include "qcom_common.h"
 #include "qcom_q6v5.h"
 
@@ -70,6 +72,8 @@
 #define TCSR_WCSS_CLK_MASK	0x1F
 #define TCSR_WCSS_CLK_ENABLE	0x14
 
+#define WCNSS_PAS_ID		6
+
 struct q6v5_wcss {
 	struct device *dev;
 
@@ -86,11 +90,17 @@ struct q6v5_wcss {
 	struct reset_control *wcss_q6_reset;
 
 	struct qcom_q6v5 q6v5;
-
+	struct clk *prng_clk;
 	phys_addr_t mem_phys;
 	phys_addr_t mem_reloc;
 	void *mem_region;
 	size_t mem_size;
+
+	bool need_mem_protection;
+	const char *m3_firmware_name;
+	
+	struct qcom_rproc_glink glink_subdev;
+	struct qcom_rproc_ssr ssr_subdev;
 };
 
 static int q6v5_wcss_reset(struct q6v5_wcss *wcss)
@@ -181,8 +191,25 @@ static int q6v5_wcss_start(struct rproc
 {
 	struct q6v5_wcss *wcss = rproc->priv;
 	int ret;
+	dev_info(wcss->dev, "q6v5_wcss_start ++\n");
+	dev_info(wcss->dev, "call clk_prepare_enable\n");
+	ret = clk_prepare_enable(wcss->prng_clk);
+	if (ret) {
+		dev_err(wcss->dev, "prng clock enable failed\n");
+		return ret;
+	}
 
 	qcom_q6v5_prepare(&wcss->q6v5);
+	
+	if (wcss->need_mem_protection) {
+		dev_info(wcss->dev, "qcom_scm_pas_auth_and_reset\n");
+		ret = qcom_scm_pas_auth_and_reset(WCNSS_PAS_ID);
+		if (ret) {
+			dev_err(wcss->dev, "wcss_reset failed\n");
+			return ret;
+		}
+		goto wait_for_reset;
+	}
 
 	/* Release Q6 and WCSS reset */
 	ret = reset_control_deassert(wcss->wcss_reset);
@@ -218,6 +245,7 @@ static int q6v5_wcss_start(struct rproc
 	if (ret)
 		goto wcss_q6_reset;
 
+wait_for_reset:
 	ret = qcom_q6v5_wait_for_start(&wcss->q6v5, 5 * HZ);
 	if (ret == -ETIMEDOUT)
 		dev_err(wcss->dev, "start timed out\n");
@@ -385,6 +413,16 @@ static int q6v5_wcss_stop(struct rproc *
 	struct q6v5_wcss *wcss = rproc->priv;
 	int ret;
 
+
+	if (wcss->need_mem_protection) {
+		ret = qcom_scm_pas_shutdown(WCNSS_PAS_ID);
+		if (ret) {
+			dev_err(wcss->dev, "not able to shutdown\n");
+			return ret;
+		}
+		goto pas_done;
+	}
+
 	/* WCSS powerdown */
 	ret = qcom_q6v5_request_stop(&wcss->q6v5);
 	if (ret == -ETIMEDOUT) {
@@ -400,7 +438,8 @@ static int q6v5_wcss_stop(struct rproc *
 	ret = q6v5_q6_powerdown(wcss);
 	if (ret)
 		return ret;
-
+pas_done:
+	clk_disable_unprepare(wcss->prng_clk);
 	qcom_q6v5_unprepare(&wcss->q6v5);
 
 	return 0;
@@ -421,7 +460,36 @@ static void *q6v5_wcss_da_to_va(struct r
 static int q6v5_wcss_load(struct rproc *rproc, const struct firmware *fw)
 {
 	struct q6v5_wcss *wcss = rproc->priv;
+	const struct firmware *m3_fw;
+	int ret;
 
+	ret = request_firmware(&m3_fw, wcss->m3_firmware_name,
+				       wcss->dev);
+	printk("Q6V5 use request_firmware\n");
+	
+	if (ret)
+		goto skip_m3;
+
+	printk("Q6V5 m3 use qcom_mdt_load_no_init\n");
+	ret = qcom_mdt_load_no_init(wcss->dev, m3_fw,
+				    wcss->m3_firmware_name, 0,
+				    wcss->mem_region, wcss->mem_phys,
+				    wcss->mem_size, &wcss->mem_reloc);
+	if (ret) {
+		dev_err(wcss->dev, "can't load m3_fw.bXX\n");
+		return ret;
+	}
+
+skip_m3:
+	if (wcss->need_mem_protection) {
+		printk("Q6V5 use qcom_mdt_load\n");
+		return qcom_mdt_load(wcss->dev, fw, rproc->firmware,
+				     WCNSS_PAS_ID, wcss->mem_region,
+				     wcss->mem_phys, wcss->mem_size,
+				     &wcss->mem_reloc);
+	}
+
+	printk("Q6V5 use qcom_mdt_load_no_init\n");
 	return qcom_mdt_load_no_init(wcss->dev, fw, rproc->firmware,
 				     0, wcss->mem_region, wcss->mem_phys,
 				     wcss->mem_size, &wcss->mem_reloc);
@@ -468,12 +536,12 @@ static int q6v5_wcss_init_mmio(struct q6
 	int ret;
 
 	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "qdsp6");
-	wcss->reg_base = devm_ioremap_resource(&pdev->dev, res);
+	wcss->reg_base = ioremap(res->start, resource_size(res));
 	if (IS_ERR(wcss->reg_base))
 		return PTR_ERR(wcss->reg_base);
 
 	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "rmb");
-	wcss->rmb_base = devm_ioremap_resource(&pdev->dev, res);
+	wcss->rmb_base = ioremap(res->start, resource_size(res));
 	if (IS_ERR(wcss->rmb_base))
 		return PTR_ERR(wcss->rmb_base);
 
@@ -541,6 +609,21 @@ static int q6v5_wcss_probe(struct platfo
 	wcss = rproc->priv;
 	wcss->dev = &pdev->dev;
 
+	wcss->prng_clk = devm_clk_get(wcss->dev, "prng");
+	if (IS_ERR(wcss->prng_clk)) {
+		ret = PTR_ERR(wcss->prng_clk);
+		if (ret != -EPROBE_DEFER)
+			dev_err(wcss->dev, "Failed to get prng clock\n");
+		goto free_rproc;
+	}
+	
+	dev_info(wcss->dev, "Got prng clock\n");
+	
+	if (qcom_scm_is_available()) {
+		dev_info(wcss->dev, "q6v5 qcom_scm_is_available ++\n");
+		wcss->need_mem_protection = true;
+	}
+
 	ret = q6v5_wcss_init_mmio(wcss, pdev);
 	if (ret)
 		goto free_rproc;
@@ -556,6 +639,9 @@ static int q6v5_wcss_probe(struct platfo
 	ret = qcom_q6v5_init(&wcss->q6v5, pdev, rproc, WCSS_CRASH_REASON, NULL);
 	if (ret)
 		goto free_rproc;
+		
+	qcom_add_glink_subdev(rproc, &wcss->glink_subdev);
+	qcom_add_ssr_subdev(rproc, &wcss->ssr_subdev, "q6wcss");
 
 	ret = rproc_add(rproc);
 	if (ret)
